import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;
import 'package:flutter_background_geolocation/flutter_background_geolocation.dart' as bg;
import '../main.dart'; // For GlobalData
import '../db/survey_database.dart';
import '../models/data_sharing_consent.dart';
import 'data_upload_service.dart'; // For LocationTrack
import 'location_encryption_service.dart';

/// Service for syncing local survey data with Qualtrics via API
class QualtricsApiService {
  // TODO: Replace with your actual Qualtrics API credentials
  static const String _baseUrl = 'https://pretoria.eu.qualtrics.com/API/v3';
  static const String _apiToken = 'WxyQMBmQvkPrL3H9YuKPCGhpCtccT7Z28KKwkMVt';
  
  // Survey IDs - Generated by QualtricsSurveyCreator
  static const String _initialSurveyId = 'SV_74i4mEa6ZTwCGQm';
  static const String _biweeklySurveyId = 'SV_baxJiGnctafu1TM';
  static const String _consentSurveyId = 'SV_bqtbNF1KVmujr9A';

  /// Sync a completed initial survey to Qualtrics
  static Future<bool> syncInitialSurvey(Map<String, dynamic> surveyData) async {
    try {
      final responseData = _mapInitialSurveyToQualtrics(surveyData);
      
      final success = await _createSurveyResponse(
        _initialSurveyId, 
        responseData,
        DateTime.parse(surveyData['submitted_at'] as String),
      );
      
      if (success) {
        debugPrint('‚úÖ Initial survey synced to Qualtrics successfully');
        // Mark as synced in local database
        final db = SurveyDatabase();
        await db.markInitialSurveySynced(surveyData['id'] as int);
      }
      
      return success;
    } catch (e) {
      debugPrint('‚ùå Failed to sync initial survey: $e');
      return false;
    }
  }

  /// Sync a completed biweekly survey to Qualtrics
  static Future<bool> syncBiweeklySurvey(Map<String, dynamic> surveyData) async {
    try {
      // Use the encrypted location data that was stored at submission time
      final encryptedLocationData = surveyData['encrypted_location_data'] as String?;
      
      // Add location data to survey data if available
      final enhancedSurveyData = Map<String, dynamic>.from(surveyData);
      if (encryptedLocationData != null) {
        enhancedSurveyData['locationJson'] = encryptedLocationData;
      }
      
      final responseData = _mapBiweeklySurveyToQualtrics(enhancedSurveyData);
      
      final success = await _createSurveyResponse(
        _biweeklySurveyId, 
        responseData,
        DateTime.parse(surveyData['submitted_at'] as String),
      );
      
      if (success) {
        debugPrint('‚úÖ Biweekly survey synced to Qualtrics successfully');
        // Mark as synced in local database
        final db = SurveyDatabase();
        await db.markRecurringSurveySynced(surveyData['id'] as int);
      }
      
      return success;
    } catch (e) {
      debugPrint('‚ùå Failed to sync biweekly survey: $e');
      return false;
    }
  }

  /// Sync a consent form to Qualtrics
  static Future<bool> syncConsentForm(Map<String, dynamic> consentData) async {
    try {
      final responseData = _mapConsentToQualtrics(consentData);
      
      final success = await _createSurveyResponse(
        _consentSurveyId, 
        responseData,
        DateTime.parse(consentData['consented_at'] as String),
      );
      
      if (success) {
        debugPrint('‚úÖ Consent form synced to Qualtrics successfully');
      }
      
      return success;
    } catch (e) {
      debugPrint('‚ùå Failed to sync consent form: $e');
      return false;
    }
  }

  /// Sync all pending surveys to Qualtrics
  static Future<void> syncPendingSurveys() async {
    try {
      final db = SurveyDatabase();
      
      // Sync pending initial surveys
      final pendingInitial = await db.getUnsyncedInitialSurveys();
      for (final survey in pendingInitial) {
        await syncInitialSurvey(survey);
        // Add small delay to avoid API rate limits
        await Future.delayed(const Duration(milliseconds: 500));
      }
      
      // Sync pending biweekly surveys  
      final pendingBiweekly = await db.getUnsyncedRecurringSurveys();
      for (final survey in pendingBiweekly) {
        await syncBiweeklySurvey(survey);
        // Add small delay to avoid API rate limits
        await Future.delayed(const Duration(milliseconds: 500));
      }
      
      debugPrint('üîÑ Completed sync of all pending surveys');
    } catch (e) {
      debugPrint('‚ùå Error syncing pending surveys: $e');
    }
  }

  /// Create a survey response in Qualtrics
  static Future<bool> _createSurveyResponse(String surveyId, Map<String, dynamic> responseData, DateTime submissionTime) async {
    try {
      final payload = {
        'responses': [
          {
            'responseId': DateTime.now().millisecondsSinceEpoch.toString(),
            'values': responseData,
            'recordedDate': submissionTime.toIso8601String(),
          }
        ]
      };

      final response = await http.post(
        Uri.parse('$_baseUrl/surveys/$surveyId/responses'),
        headers: {
          'X-API-TOKEN': _apiToken,
          'Content-Type': 'application/json',
          'Accept': 'application/json',
        },
        body: jsonEncode(payload),
      );

      if (response.statusCode == 200 || response.statusCode == 201) {
        final responseJson = jsonDecode(response.body);
        final responseId = responseJson['result']['id'];
        debugPrint('‚úÖ Survey response created with ID: $responseId');
        return true;
      } else {
        debugPrint('‚ùå Qualtrics API error: ${response.statusCode} - ${response.body}');
        return false;
      }
    } catch (e) {
      debugPrint('‚ùå Network error creating survey response: $e');
      return false;
    }
  }

  /// Map initial survey data to Qualtrics format
  static Map<String, dynamic> _mapInitialSurveyToQualtrics(Map<String, dynamic> survey) {
    final data = <String, dynamic>{};
    
    // Add participant UUID from global data
    data['QID_PARTICIPANT_UUID'] = GlobalData.userUUID;
    
    // Map survey fields to Qualtrics question IDs
    if (survey['age'] != null) data['QID_AGE'] = survey['age'].toString();
    if (survey['ethnicity'] != null) {
      final ethnicity = jsonDecode(survey['ethnicity'] as String) as List;
      data['QID_ETHNICITY'] = ethnicity.join(',');
    }
    if (survey['gender'] != null) data['QID_GENDER'] = survey['gender'];
    if (survey['sexuality'] != null) data['QID_SEXUALITY'] = survey['sexuality'];
    if (survey['birth_place'] != null) data['QID_BIRTH_PLACE'] = survey['birth_place'];
    if (survey['suburb'] != null) data['QID_SUBURB'] = survey['suburb'];
    if (survey['building_type'] != null) data['QID_BUILDING_TYPE'] = survey['building_type'];
    if (survey['household_items'] != null) {
      final items = jsonDecode(survey['household_items'] as String) as List;
      data['QID_HOUSEHOLD_ITEMS'] = items.join(',');
    }
    if (survey['education'] != null) data['QID_EDUCATION'] = survey['education'];
    if (survey['climate_activism'] != null) data['QID_CLIMATE_ACTIVISM'] = survey['climate_activism'];
    if (survey['general_health'] != null) data['QID_GENERAL_HEALTH'] = survey['general_health'];
    if (survey['research_site'] != null) data['QID_RESEARCH_SITE'] = survey['research_site'];
    if (survey['submitted_at'] != null) data['QID_SUBMITTED_AT'] = survey['submitted_at'];
    
    return data;
  }

  /// Map biweekly survey data to Qualtrics format
  static Map<String, dynamic> _mapBiweeklySurveyToQualtrics(Map<String, dynamic> survey) {
    final data = <String, dynamic>{};
    
    // Add participant UUID
    data['QID_PARTICIPANT_UUID'] = GlobalData.userUUID;
    
    // Map survey fields to Qualtrics question IDs
    if (survey['activities'] != null) {
      final activities = jsonDecode(survey['activities'] as String) as List;
      data['QID_ACTIVITIES'] = activities.join(',');
    }
    if (survey['living_arrangement'] != null) data['QID_LIVING_ARRANGEMENT'] = survey['living_arrangement'];
    if (survey['relationship_status'] != null) data['QID_RELATIONSHIP_STATUS'] = survey['relationship_status'];
    if (survey['general_health'] != null) data['QID_GENERAL_HEALTH'] = survey['general_health'];
    
    // Wellbeing questions
    if (survey['cheerful_spirits'] != null) data['QID_CHEERFUL_SPIRITS'] = survey['cheerful_spirits'].toString();
    if (survey['calm_relaxed'] != null) data['QID_CALM_RELAXED'] = survey['calm_relaxed'].toString();
    if (survey['active_vigorous'] != null) data['QID_ACTIVE_VIGOROUS'] = survey['active_vigorous'].toString();
    if (survey['woke_up_fresh'] != null) data['QID_WOKE_UP_FRESH'] = survey['woke_up_fresh'].toString();
    if (survey['daily_life_interesting'] != null) data['QID_DAILY_LIFE_INTERESTING'] = survey['daily_life_interesting'].toString();
    
    // Personal characteristics
    if (survey['cooperate_with_people'] != null) data['QID_COOPERATE_WITH_PEOPLE'] = survey['cooperate_with_people'].toString();
    if (survey['improving_skills'] != null) data['QID_IMPROVING_SKILLS'] = survey['improving_skills'].toString();
    if (survey['social_situations'] != null) data['QID_SOCIAL_SITUATIONS'] = survey['social_situations'].toString();
    if (survey['family_support'] != null) data['QID_FAMILY_SUPPORT'] = survey['family_support'].toString();
    if (survey['family_knows_me'] != null) data['QID_FAMILY_KNOWS_ME'] = survey['family_knows_me'].toString();
    if (survey['access_to_food'] != null) data['QID_ACCESS_TO_FOOD'] = survey['access_to_food'].toString();
    if (survey['people_enjoy_time'] != null) data['QID_PEOPLE_ENJOY_TIME'] = survey['people_enjoy_time'].toString();
    if (survey['talk_to_family'] != null) data['QID_TALK_TO_FAMILY'] = survey['talk_to_family'].toString();
    if (survey['friends_support'] != null) data['QID_FRIENDS_SUPPORT'] = survey['friends_support'].toString();
    if (survey['belong_in_community'] != null) data['QID_BELONG_IN_COMMUNITY'] = survey['belong_in_community'].toString();
    if (survey['family_stands_by_me'] != null) data['QID_FAMILY_STANDS_BY_ME'] = survey['family_stands_by_me'].toString();
    if (survey['friends_stand_by_me'] != null) data['QID_FRIENDS_STAND_BY_ME'] = survey['friends_stand_by_me'].toString();
    if (survey['treated_fairly'] != null) data['QID_TREATED_FAIRLY'] = survey['treated_fairly'].toString();
    if (survey['opportunities_responsibility'] != null) data['QID_OPPORTUNITIES_RESPONSIBILITY'] = survey['opportunities_responsibility'].toString();
    if (survey['secure_with_family'] != null) data['QID_SECURE_WITH_FAMILY'] = survey['secure_with_family'].toString();
    if (survey['opportunities_abilities'] != null) data['QID_OPPORTUNITIES_ABILITIES'] = survey['opportunities_abilities'].toString();
    if (survey['enjoy_cultural_traditions'] != null) data['QID_ENJOY_CULTURAL_TRADITIONS'] = survey['enjoy_cultural_traditions'].toString();
    
    // Digital diary
    if (survey['environmental_challenges'] != null) data['QID_ENVIRONMENTAL_CHALLENGES'] = survey['environmental_challenges'];
    if (survey['challenges_stress_level'] != null) data['QID_CHALLENGES_STRESS_LEVEL'] = survey['challenges_stress_level'];
    if (survey['coping_help'] != null) data['QID_COPING_HELP'] = survey['coping_help'];
    
    // Media files (store as comma-separated URLs)
    if (survey['voice_note_urls'] != null) {
      final voiceUrls = jsonDecode(survey['voice_note_urls'] as String) as List;
      data['QID_VOICE_NOTE_URLS'] = voiceUrls.join(',');
    }
    if (survey['image_urls'] != null) {
      final imageUrls = jsonDecode(survey['image_urls'] as String) as List;
      data['QID_IMAGE_URLS'] = imageUrls.join(',');
    }
    
    // Metadata
    if (survey['research_site'] != null) data['QID_RESEARCH_SITE'] = survey['research_site'];
    if (survey['submitted_at'] != null) data['QID_SUBMITTED_AT'] = survey['submitted_at'];
    
    // Location data (encrypted)
    if (survey['locationJson'] != null) data['QID_LOCATION_DATA'] = survey['locationJson'];
    
    return data;
  }

  /// Map consent form data to Qualtrics format
  static Map<String, dynamic> _mapConsentToQualtrics(Map<String, dynamic> consent) {
    final data = <String, dynamic>{};
    
    // Add participant identifiers
    if (consent['participant_code'] != null) data['QID_PARTICIPANT_CODE'] = consent['participant_code'];
    if (consent['participant_uuid'] != null) data['QID_PARTICIPANT_UUID'] = consent['participant_uuid'];
    
    // Map consent checkboxes (1 = checked, 0 = unchecked)
    data['QID_INFORMED_CONSENT'] = (consent['informed_consent'] == true) ? '1' : '0';
    data['QID_DATA_PROCESSING'] = (consent['data_processing'] == true) ? '1' : '0';
    data['QID_LOCATION_DATA'] = (consent['location_data'] == true) ? '1' : '0';
    data['QID_SURVEY_DATA'] = (consent['survey_data'] == true) ? '1' : '0';
    data['QID_DATA_RETENTION'] = (consent['data_retention'] == true) ? '1' : '0';
    data['QID_DATA_SHARING'] = (consent['data_sharing'] == true) ? '1' : '0';
    data['QID_VOLUNTARY_PARTICIPATION'] = (consent['voluntary_participation'] == true) ? '1' : '0';
    
    // Add signature and timestamp
    if (consent['participant_signature'] != null) data['QID_PARTICIPANT_SIGNATURE'] = consent['participant_signature'];
    if (consent['consented_at'] != null) data['QID_CONSENTED_AT'] = consent['consented_at'];
    
    return data;
  }

  /// Get encrypted location data for a specific submission time (public method for use during survey submission)
  static Future<String?> getEncryptedLocationDataForSubmissionTime(String? participantUuid, DateTime submissionTime) async {
    if (participantUuid == null) return null;
    
    try {
      final db = SurveyDatabase();
      
      // Get user's latest consent decision
      final consent = await db.getLatestDataSharingConsent(participantUuid);
      if (consent == null || consent.locationSharingOption == LocationSharingOption.surveyOnly) {
        print('[QualtricsApiService] No location consent or survey-only mode - skipping location data');
        return null;
      }
      
      // Get location data based on consent for the 2 weeks prior to submission time
      List<LocationTrack> locationTracks = [];
      
      switch (consent.locationSharingOption) {
        case LocationSharingOption.fullData:
          // Get all location data from 2 weeks before submission time
          locationTracks = await _getLocationTracksForTimeRange(submissionTime.subtract(Duration(days: 14)), submissionTime);
          break;
          
        case LocationSharingOption.partialData:
          // Get filtered location data based on user's selection for the time range
          locationTracks = await _getPartialLocationDataForTimeRange(consent, submissionTime.subtract(Duration(days: 14)), submissionTime);
          break;
          
        case LocationSharingOption.surveyOnly:
          // No location data
          return null;
      }
      
      if (locationTracks.isEmpty) {
        print('[QualtricsApiService] No location data available for encryption (submission time: $submissionTime)');
        return null;
      }
      
      // Convert location tracks to JSON format
      final locationData = locationTracks.map((track) => {
        'latitude': track.latitude,
        'longitude': track.longitude,
        'timestamp': track.timestamp.toIso8601String(),
        'accuracy': track.accuracy,
        'altitude': track.altitude,
        'speed': track.speed,
        'activity': track.activity,
      }).toList();
      
      final locationJson = jsonEncode(locationData);
      
      // Encrypt the location data using the same encryption service
      final encryptedLocation = await LocationEncryptionService.encryptLocationData(locationJson);
      
      print('[QualtricsApiService] Successfully encrypted ${locationTracks.length} location records for submission time: $submissionTime');
      return encryptedLocation;
      
    } catch (e) {
      print('[QualtricsApiService] Error getting encrypted location data for submission time: $e');
      return null;
    }
  }

  /// Get location tracks for a specific time range
  static Future<List<LocationTrack>> _getLocationTracksForTimeRange(DateTime startTime, DateTime endTime) async {
    if (kIsWeb) return [];
    
    try {
      final bgLocations = await bg.BackgroundGeolocation.locations;
      final locationTracks = <LocationTrack>[];
      
      for (var bgLocation in bgLocations) {
        try {
          final locationMap = bgLocation as Map<Object?, Object?>;
          
          // Handle timestamp
          DateTime locationTime;
          final timestamp = locationMap['timestamp'];
          if (timestamp is int) {
            locationTime = DateTime.fromMillisecondsSinceEpoch(timestamp);
          } else if (timestamp is String) {
            locationTime = DateTime.parse(timestamp);
          } else {
            continue;
          }
          
          // Check if location is within the specified time range
          if (locationTime.isAfter(startTime) && locationTime.isBefore(endTime)) {
            final coords = locationMap['coords'] as Map<Object?, Object?>?;
            if (coords != null) {
              locationTracks.add(LocationTrack(
                timestamp: locationTime,
                latitude: coords['latitude'] as double,
                longitude: coords['longitude'] as double,
                accuracy: coords['accuracy'] as double?,
                altitude: coords['altitude'] as double?,
                speed: coords['speed'] as double?,
                activity: (locationMap['activity'] as Map<Object?, Object?>?)?['type'] as String?,
              ));
            }
          }
        } catch (e) {
          continue;
        }
      }
      
      print('[QualtricsApiService] Retrieved ${locationTracks.length} location tracks for time range ${startTime.toIso8601String()} to ${endTime.toIso8601String()}');
      return locationTracks;
    } catch (e) {
      print('[QualtricsApiService] Error getting background locations for time range: $e');
      return [];
    }
  }

  /// Get filtered location data for partial sharing based on user's consent for a specific time range
  static Future<List<LocationTrack>> _getPartialLocationDataForTimeRange(DataSharingConsent consent, DateTime startTime, DateTime endTime) async {
    final allTracks = await _getLocationTracksForTimeRange(startTime, endTime);
    
    if (consent.customLocationIds == null || consent.customLocationIds!.isEmpty) {
      return [];
    }
    
    // For partial sharing, the consent system stores track indices or cluster IDs
    // We need to filter based on the selected locations
    final selectedTracks = <LocationTrack>[];
    
    // This logic should match the selection logic from the consent dialog
    // For now, we'll implement a basic filtering system
    // In a production app, this would need more sophisticated geofencing
    
    // Simple implementation: if user selected any custom locations, include all tracks
    // This should be enhanced to match the actual cluster/area selection logic
    if (consent.customLocationIds!.isNotEmpty) {
      selectedTracks.addAll(allTracks);
    }
    
    print('[QualtricsApiService] Filtered to ${selectedTracks.length} location tracks for partial sharing (time range)');
    return selectedTracks;
  }
}
